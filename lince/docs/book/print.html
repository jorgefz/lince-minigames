<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lince Documentation Website</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="HomePage.html">Home Page</a></li><li class="chapter-item expanded "><a href="App.html"><strong aria-hidden="true">1.</strong> App</a></li><li class="chapter-item expanded "><a href="Events.html"><strong aria-hidden="true">2.</strong> Events</a></li><li class="chapter-item expanded "><a href="Layers.html"><strong aria-hidden="true">3.</strong> Layers</a></li><li class="chapter-item expanded "><a href="Input.html"><strong aria-hidden="true">4.</strong> Input</a></li><li class="chapter-item expanded "><a href="Rendering.html"><strong aria-hidden="true">5.</strong> Rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Buffers.html"><strong aria-hidden="true">5.1.</strong> Buffers</a></li><li class="chapter-item expanded "><a href="VertexArrays.html"><strong aria-hidden="true">5.2.</strong> Vertex Arrays</a></li><li class="chapter-item expanded "><a href="Shaders.html"><strong aria-hidden="true">5.3.</strong> Shaders</a></li><li class="chapter-item expanded "><a href="Textures.html"><strong aria-hidden="true">5.4.</strong> Textures</a></li><li class="chapter-item expanded "><a href="Renderer.html"><strong aria-hidden="true">5.5.</strong> Renderer</a></li><li class="chapter-item expanded "><a href="Cameras.html"><strong aria-hidden="true">5.6.</strong> Cameras</a></li></ol></li><li class="chapter-item expanded "><a href="UI.html"><strong aria-hidden="true">6.</strong> UI</a></li><li class="chapter-item expanded "><a href="Tiles.html"><strong aria-hidden="true">7.</strong> Tiles</a></li><li class="chapter-item expanded "><a href="DevDiary.html"><strong aria-hidden="true">8.</strong> Development Diary</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ToDo.html"><strong aria-hidden="true">8.1.</strong> ToDo</a></li><li class="chapter-item expanded "><a href="Versions.html"><strong aria-hidden="true">8.2.</strong> Version History</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Lince Documentation Website</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lince-game-engine"><a class="header" href="#lince-game-engine">Lince Game Engine</a></h1>
<p>Lince is a game engine written entirely in C targetted towards 2D games. The engine is currently a work in progress, and it's so early in its development that it doesn't even qualify as pre-alpha - the basic foundations of the renderer are being built and it won't be usable for some time.</p>
<h2 id="basic-code-example"><a class="header" href="#basic-code-example">Basic Code Example</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;lince.h&quot;

void Init() {
	printf(&quot; Game started!\n&quot;);
}

void OnUpdate(float dt) {
	printf(&quot; dt = %.3f ms\n&quot;, dt * 1000.0f);
}

void Terminate() {
	printf(&quot; Game terminated!\n&quot;);
}

int main() {

	LinceApp* app = LinceGetAppState();

	app-&gt;game_init = Init;
	app-&gt;game_on_update = OnUpdate;
	app-&gt;game_terminate = Terminate;

	LinceRun();

	return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app"><a class="header" href="#app">App</a></h1>
<h2 id="linceapp"><a class="header" href="#linceapp">LinceApp</a></h2>
<p>Structure members of <code>LinceApp</code>.</p>
<p>The global state of the application is stored in a <code>LinceApp</code> structure allocated on the stack. Prior to running the application, the user may change the program's settings via this structure.</p>
<p>Once the settings have been tuned, call the function <code>LinceRun()</code> to initialise the application.</p>
<h3 id="user-settings"><a class="header" href="#user-settings">User settings</a></h3>
<ul>
<li><code>void* user_data</code>
<ul>
<li>Pointer for custom data set by the user</li>
</ul>
</li>
<li><code>uint32_t screen_width</code>
<ul>
<li>Desired window width - should be set before calling <code>LinceRun</code></li>
</ul>
</li>
<li><code>uint32_t screen_height</code>
<ul>
<li>Desired window height - should be set before calling <code>LinceRun</code></li>
</ul>
</li>
<li><code>const char* title</code>
<ul>
<li>String title for the window - should be set before calling <code>LinceRun</code></li>
</ul>
</li>
</ul>
<h3 id="user-callbacks"><a class="header" href="#user-callbacks">User callbacks</a></h3>
<p>These callbacks should be set before the applciation starts running.</p>
<ul>
<li><code>void game_init(void)</code>
<ul>
<li>Function called when the program starts.</li>
</ul>
</li>
<li><code>void game_on_update(float dt)</code>
<ul>
<li>Function called on every game tick.</li>
<li>The sole argument <code>float dt</code> is the delta time between frames.</li>
</ul>
</li>
<li><code>void game_on_event(LinceEvent* event)</code>
<ul>
<li>Function called when engine event takes place</li>
<li>The argument <code>event</code> is the engine event that the user can handle.</li>
</ul>
</li>
<li><code>void game_terminate(void)</code>
<ul>
<li>Function called when the application is closed.</li>
<li>You should free your allocated memory here.</li>
</ul>
</li>
</ul>
<h3 id="internal-state"><a class="header" href="#internal-state">Internal state</a></h3>
<p>These structure members handle the internal state of the application and do not act as user-defined settings.</p>
<ul>
<li><code>LinceWindow* window</code>
<ul>
<li>Stores the state of the window as well as the handle to the GLFw window object.</li>
</ul>
</li>
<li><code>LinceLayerStack* layer_stack</code>
<ul>
<li>Stack of rendering layers that are drawn from last to first.</li>
<li>These are added by the user.</li>
</ul>
</li>
<li><code>LinceLayerStack* overlay_stack</code>
<ul>
<li>Stack of overlays, which are layers that are rendered on top of the game proper. </li>
<li>These usually constitute UI elements and menus.</li>
</ul>
</li>
<li><code>LinceBool running</code>
<ul>
<li>Boolean that indicates whether the program is running.</li>
</ul>
</li>
<li><code>float time_ms</code>
<ul>
<li>Number of milliseconds since the start of the application.</li>
</ul>
</li>
<li><code>float dt</code>
<ul>
<li>Time step in seconds between frames, calculated from the system clock.</li>
</ul>
</li>
<li><code>int current_layer</code>
<ul>
<li>Index of the layer that is being rendered on the layer stack.</li>
<li>If no layer is active, this takes the value <code>-1</code>.</li>
</ul>
</li>
<li><code>int current_overlay</code>
<ul>
<li>Index of the overlay that is being rendered on the overlay stack.</li>
<li>If no overlay is active, this takes the value <code>-1</code>.</li>
</ul>
</li>
</ul>
<h2 id="lincegetappstate"><a class="header" href="#lincegetappstate">LinceGetAppState</a></h2>
<pre><code class="language-c">LinceApp* LinceGetAppState()
</code></pre>
<p>Returns a pointer the the application state and user settings.</p>
<p>Example:</p>
<pre><code class="language-c">void Init() {
	printf(&quot; Game started!\n&quot;);
}

void OnUpdate(float dt) {
	printf(&quot; dt = %.3f ms\n&quot;, dt * 1000.0f);
}

void Terminate() {
	printf(&quot; Game terminated!\n&quot;);
}

int main() {

	// setup callbacks
	LinceApp* app = LinceGetAppState();
	app-&gt;game_init = Init;
	app-&gt;game_on_update = OnUpdate;
	app-&gt;game_terminate = Terminate;

	// start the application
	LinceRun();

	return 0;
}
</code></pre>
<h2 id="lincerun"><a class="header" href="#lincerun">LinceRun</a></h2>
<pre><code class="language-c">void LinceRun()
</code></pre>
<p>Creates a window and initialises the application. At this point, you should interact with the app via the callback functions.</p>
<h2 id="lincecheckerrors"><a class="header" href="#lincecheckerrors">LinceCheckErrors</a></h2>
<pre><code class="language-c">void LinceCheckErrors()
</code></pre>
<p>Fetches OpenGL errors and stops the application if one is found.</p>
<h2 id="lincegettimemillis"><a class="header" href="#lincegettimemillis">LinceGetTimeMillis</a></h2>
<pre><code class="language-c">double LinceGetTimeMillis()
</code></pre>
<p>Returns the number of milliseconds since the application started.</p>
<h2 id="lincegetaspectratio"><a class="header" href="#lincegetaspectratio">LinceGetAspectRatio</a></h2>
<pre><code class="language-c">float LinceGetAspectRatio()
</code></pre>
<p>Returns the aspect ratio of the application window.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>Events are generated when a certain action is executed, either by the player or by the application. Examples are mouse button clicks, key strokes, mouse movement, and window resizing. Every time an event takes place, a callback function is called and a <code>LinceEvent</code> object is generated and propagated through the engine. If set, your game will receive this events through a custom <code>OnEvent</code> function via the <code>game_on_event</code> callback (see <a href="./App.html">App</a>).</p>
<p>Events are first passed to the application's <code>game_on_event</code> (see <a href="./App.html">App</a>) and then to the OnEvent callback of each of the overlays and layers (see <a href="./Layers.html">Layers</a>).</p>
<h2 id="linceevent"><a class="header" href="#linceevent">LinceEvent</a></h2>
<p>Structure that holds the data relevant to an event.</p>
<ul>
<li><code>LinceEventType type</code>
<ul>
<li>Enum that describes the type of event (see <a href="Events.html##LinceEventType">LinceEventType</a>). </li>
</ul>
</li>
<li><code>LinceBool handled</code>
<ul>
<li>Boolean that indicates whether the event should be propagated further.</li>
</ul>
</li>
<li><code>LinceEventData data</code>
<ul>
<li>Union that holds the data for all the possible types of events</li>
<li>You should only retrieve the data corresponding to the event's type.</li>
</ul>
</li>
<li><code>char name[LINCE_NAME_MAX]</code>
<ul>
<li>Debug name, unused.</li>
</ul>
</li>
</ul>
<h2 id="linceeventtype"><a class="header" href="#linceeventtype">LinceEventType</a></h2>
<p>Event types predefined by the engine.</p>
<div class="table-wrapper"><table><thead><tr><th>Enum</th><th>Value</th></tr></thead><tbody>
<tr><td>LinceEventType_None</td><td>0</td></tr>
<tr><td>LinceEventType_WindowClose</td><td>1</td></tr>
<tr><td>LinceEventType_WindowResize</td><td>2</td></tr>
<tr><td>LinceEventType_KeyPressed</td><td>3</td></tr>
<tr><td>LinceEventType_KeyReleased</td><td>4</td></tr>
<tr><td>LinceEventType_KeyType</td><td>5</td></tr>
<tr><td>LinceEventType_MouseButtonPressed</td><td>6</td></tr>
<tr><td>LinceEventType_MouseButtonReleased</td><td>7</td></tr>
<tr><td>LinceEventType_MouseMoved</td><td>8</td></tr>
<tr><td>LinceEventType_MouseScrolled</td><td>9</td></tr>
<tr><td>LinceEventType_EventNum</td><td>10</td></tr>
</tbody></table>
</div>
<h2 id="lincedispatchevent"><a class="header" href="#lincedispatchevent">LinceDispatchEvent</a></h2>
<pre><code class="language-c">LinceBool LinceDispatchEvent(LinceEvent* event, LinceEventType event_type, LinceEventFn callback)
</code></pre>
<p>Handles a given event with a callback only if it matches the given event type.</p>
<p>Parameters:</p>
<ul>
<li><code>LinceEvent* event</code>
<ul>
<li>Event to dispatch</li>
</ul>
</li>
<li><code>LinceEventType event_type</code>
<ul>
<li>Desired type of the event to dispatch</li>
</ul>
</li>
<li><code>LinceEventFn callback</code>: function that is called to handle the event if it is of the desired type. It must have the signature <code>LinceBool callback(LinceEvent*)</code> and should return <code>LinceTrue</code> (= 1) if it handled the event, and <code>LinceFalse</code> (= 0) otherwise.</li>
</ul>
<p>Returns:</p>
<ul>
<li><code>LinceBool</code>: boolean indicates whether event has been handled and should not be propagated further.</li>
</ul>
<p>Example:</p>
<pre><code class="language-c">LinceBool OnMouseClick(LinceEvent* e){
	printf(&quot;Mouse button clicked!\n&quot;);
	return LinceFalse;
}

void GameOnEvent(LinceEvent* e){
	LinceDispatchEvent(e, LinceEventType_MouseButtonPressed, OnMouseClick);
}
</code></pre>
<h2 id="keypressedevent"><a class="header" href="#keypressedevent">KeyPressedEvent</a></h2>
<p>Takes place when a key on the keyboard is pressed. Usually, this occurs once when the key is pressed, and then after a cooldown, it occurs repeatedly if the key is held down. The specific event data is retrieved via <code>LinceEvent.data.KeyPressed</code>.</p>
<p>Data:</p>
<ul>
<li><code>int keycode</code>
<ul>
<li>Keycode as defined by the enum <code>LinceKey</code> (see <a href="./Input.html">Input</a> chapter).</li>
</ul>
</li>
<li><code>int repeats</code>
<ul>
<li>Number of repeat events generated when a key is held down. Currently unused.</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code class="language-c">LinceBool OnKeyPress(LinceEvent* e){
	KeyPressedEvent* kp = e-&gt;data.KeyPressed;
	printf(&quot; Key pressed: %d\n&quot;, kp-&gt;keycode);
	return LinceFalse;
}
</code></pre>
<h2 id="keyreleasedevent"><a class="header" href="#keyreleasedevent">KeyReleasedEvent</a></h2>
<p>Takes place when a keyboard key is released. The specific event data is retrieved via <code>LinceEvent.data.KeyReleased</code>.</p>
<p>Data:</p>
<ul>
<li><code>int keycode</code>
<ul>
<li>Key code as defined by the enum <code>LinceKey</code> (see <a href="./Input.html">Input</a> chapter).</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code class="language-c">LinceBool OnKeyRelease(LinceEvent* e){
	KeyReleasedEvent* kr = e-&gt;data.KeyReleased;
	printf(&quot; Key released: %d\n&quot;, kr-&gt;keycode);
	return LinceFalse;
}
</code></pre>
<h2 id="keytypeevent"><a class="header" href="#keytypeevent">KeyTypeEvent</a></h2>
<p>Takes place when text is being typed. The specific event data is retrieved via <code>LinceEvent.data.KeyType</code>.</p>
<p>Data:</p>
<ul>
<li><code>int keycode</code>
<ul>
<li>Key code as defined by the enum <code>LinceKey</code> (see <a href="./Input.html">Input</a> chapter).</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code class="language-c">LinceBool OnKeyType(LinceEvent* e){
	KeyTypeEvent* kt = e-&gt;data.KeyType;
	printf(&quot;Key typed: %d\n&quot;, kt-&gt;keycode);
	return LinceFalse;
}
</code></pre>
<h2 id="windowcloseevent"><a class="header" href="#windowcloseevent">WindowCloseEvent</a></h2>
<p>Takes place when the window has been signaled to close. The specific event data is retrieved via <code>LinceEvent.data.WindowClose</code>, although it holds no usable data but a dummy heap-allocated integer whose value is unused.</p>
<p>Data:</p>
<ul>
<li><code>int dummy</code>
<ul>
<li>Unused placeholder data. The event being generated in the first place is indicative that the window should close.</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code class="language-c">LinceBool OnWindowClose(LinceEvent* e){
	printf(&quot; Closing window!\n&quot;);
	FreeMemory();
	TerminateGame();
	return LinceTrue;
}
</code></pre>
<h2 id="windowresizeevent"><a class="header" href="#windowresizeevent">WindowResizeEvent</a></h2>
<p>Takes place when the size or shape of the window is changed. The specific event data is retrieved via <code>LinceEvent.data.WindowResize</code>.</p>
<p>Data:</p>
<ul>
<li><code>unsigned int height</code>
<ul>
<li>New height of the window in pixels.</li>
</ul>
</li>
<li><code>unsigned int width</code>
<ul>
<li>New width of the window in pixels.</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code class="language-c">LinceBool OnWindowResize(LinceEvent* e){
	WindowResizeEvent* wr = e-&gt;data.WindowResize;
	printf(&quot; Window resized to %ux%u\n&quot;, wr-&gt;width, wr-&gt;height);
	return LinceFalse;
}
</code></pre>
<h2 id="mousebuttonpressedevent"><a class="header" href="#mousebuttonpressedevent">MouseButtonPressedEvent</a></h2>
<p>Takes place when a mouse button is clicked. The specific event data is retrieved via <code>LinceEvent.data.MouseButtonPressed</code>.</p>
<p>Data:</p>
<ul>
<li><code>int button</code>
<ul>
<li>Button code defined by the enum <code>LinceMouseButton</code> (see <a href="./Input.html">Input</a> chapter).</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code class="language-c">LinceBool OnMouseButtonPress(LinceEvent* e){
	MouseButtonPressedEvent* mbp = e-&gt;data.MouseButtonPressed;
	printf(&quot; Mouse button pressed: %d\n&quot;, mbp-&gt;button);
	return LinceFalse;
}
</code></pre>
<h2 id="mousebuttonreleasedevent"><a class="header" href="#mousebuttonreleasedevent">MouseButtonReleasedEvent</a></h2>
<p>Takes place when a mouse button is released. The specific event data is retrieved via <code>LinceEvent.data.MouseButtonReleased</code>.</p>
<p>Data:</p>
<ul>
<li><code>int button</code>
<ul>
<li>Button code defined by the enum <code>LinceMouseButton</code> (see <a href="./Input.html">Input</a> chapter).</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code class="language-c">LinceBool OnMouseButtonRelease(LinceEvent* e){
	MouseButtonReleasedEvent* mbr = e-&gt;data.MouseButtonReleased;
	printf(&quot; Mouse button released: %d\n&quot;, mbr-&gt;button);
	return LinceFalse;
}
</code></pre>
<h2 id="mousemovedevent"><a class="header" href="#mousemovedevent">MouseMovedEvent</a></h2>
<p>Takes place when the mouse is moved anywhere on the screen. The specific event data is retrieved via <code>LinceEvent.data.MouseMoved</code>.</p>
<p>Data:</p>
<ul>
<li><code>float xpos</code>
<ul>
<li>New X position of the mouse in screen coordinates with origin on the top-left corner of the window.</li>
</ul>
</li>
<li><code>float ypos</code>
<ul>
<li>New Y position of the mouse in screen coordinates with origin on the top-left corner of the window.</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code class="language-c">LinceBool OnMouseMoved(LinceEvent* e){
	MouseMovedEvent* mm = e-&gt;data.MouseMoved;
	printf(&quot; Mouse moved to %.3f,%.3f\n&quot;, mm-&gt;xpos, mm-&gt;ypos);
	return LinceFalse;
}
</code></pre>
<h2 id="mousescrolledevent"><a class="header" href="#mousescrolledevent">MouseScrolledEvent</a></h2>
<p>Takes place when scrolling occurs, either via the mouse wheel or a touchpad gesture. Typical mouse wheel scrolling only provides a Y coordinate, whereas touchpad scrolling is two dimensional (zooming, panning, etc). The specific event data is retrieved via <code>LinceEvent.data.MouseScrolled</code>.</p>
<p>Data:</p>
<ul>
<li><code>float xoff</code>
<ul>
<li>Magnitude of the scroll on the X axis</li>
</ul>
</li>
<li><code>float yoff</code>
<ul>
<li>Magnitude of the scroll on the Y axis</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code class="language-c">LinceBool OnMouseScrolled(LinceEvent* e){
	MouseScrolledEvent* mm = e-&gt;data.MouseScrolled;
	printf(&quot; Mouse scrolled by %.3f,%.3f\n&quot;, mm-&gt;xoff, mm-&gt;yoff);
	return LinceFalse;
}
</code></pre>
<h2 id="genericevent"><a class="header" href="#genericevent">GenericEvent</a></h2>
<p>This is an additional member of the <code>LinceEvent.data</code> union that can point to any raw data via a <code>void*</code> pointer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layers"><a class="header" href="#layers">Layers</a></h1>
<p>A layer is a set of geometry that is rendered together, usually in a single batch, but it can be split into more batches when there's a lot of vertices.</p>
<p>A layer system in a game engine is important to separate the rendering process into steps, with the vertices on each having different properties, roles, and being rendered in a different order (some layers are rendered after / above others).</p>
<h2 id="lincelayer"><a class="header" href="#lincelayer">LinceLayer</a></h2>
<p>The data structure that saves the state of a layer.</p>
<ul>
<li><code>void OnAttach(LinceLayer* layer)</code>
<ul>
<li>Callback called when a layer is added to the stack.</li>
</ul>
</li>
<li><code>void OnDetach(LinceLayer* layer)</code>
<ul>
<li>Callback called when a layer is removed from the stack.</li>
</ul>
</li>
<li><code>void OnUpdate(LinceLayer* layer, float dt)</code>
<ul>
<li>Callback called on every frame.</li>
<li>The second argument <code>float dt</code> is the delta time in seconds.</li>
</ul>
</li>
<li><code>void OnEvent(LinceLayer* layer, LinceEvent* event)</code>
<ul>
<li>Callback called when an event is propagated.</li>
</ul>
</li>
<li><code>void* data</code>
<ul>
<li>Custom user data which should be a pointer to an user-defined layer structure.</li>
</ul>
</li>
</ul>
<h3 id="example-code"><a class="header" href="#example-code">Example code</a></h3>
<p>This is a simple example of how to create and use a layer in Lince.</p>
<pre><code class="language-c">void MyLayerOnAttach(LinceLayer* layer){
	printf(&quot;MyLayer attached\n&quot;);
}

void MyLayerOnDetach(LinceLayer* layer){
	printf(&quot;MyLayer detached\n&quot;);
}

void MyLayerOnUpdate(LinceLayer* layer, float dt){

}

void MyLayerOnEvent(LinceLayer* layer, LinceEvent* e){

}

void GameInit(){

	LinceLayer* layer = LinceCreateLayer(NULL);

	layer-&gt;OnAttach = MyLayerOnAttach;
	layer-&gt;OnDetach = MyLayerOnDetach;
	layer-&gt;OnUpdate = MyLayerOnUpdate;
	layer-&gt;OnEvent = MyLayerOnEvent;

	LincePushLayer(layer);
}

int main(){
	// set user callbacks
	LinceApp* app = LinceGetAppState();
	app-&gt;game_init = GameInit;
	
	// run the application
	LinceRun();

	return 0;
}
</code></pre>
<h2 id="lincecreatelayer"><a class="header" href="#lincecreatelayer">LinceCreateLayer</a></h2>
<pre><code class="language-c">LinceLayer* LinceCreateLayer(void* data)
</code></pre>
<p>Allocates a new layer.</p>
<p>Parameters:</p>
<ul>
<li><code>void* data</code>
<ul>
<li>Custom user layer data
Returns:</li>
</ul>
</li>
<li><code>LinceLayer*</code>
<ul>
<li>Pointer to allocated layer</li>
</ul>
</li>
</ul>
<h2 id="lincegetlayerdata"><a class="header" href="#lincegetlayerdata">LinceGetLayerData</a></h2>
<pre><code class="language-c">void* LinceGetLayerData(LinceLayer* layer)
</code></pre>
<p>Deprecated. Retrieves user data from a layer.</p>
<h2 id="lincepushlayer"><a class="header" href="#lincepushlayer">LincePushLayer</a></h2>
<pre><code class="language-c">void LincePushLayer(LinceLayer* layer)
</code></pre>
<p>Appends a layer to the application's layer stack.</p>
<h2 id="lincepushoverlay"><a class="header" href="#lincepushoverlay">LincePushOverlay</a></h2>
<pre><code class="language-c">void LincePushOverlay(LinceLayer* layer)
</code></pre>
<p>Appends an overlay to the application's overlay stack.</p>
<h2 id="lincegetcurrentlayer"><a class="header" href="#lincegetcurrentlayer">LinceGetCurrentLayer</a></h2>
<pre><code class="language-c">LinceLayer* LinceGetCurrentLayer()
</code></pre>
<p>Retrieves a pointer to the current active layer.
If no layer is active, returns NULL.
This is useful when you need to retrieve layer data from within callbacks called on the layer's OnUpdate and OnEvent functions.</p>
<h2 id="lincegetcurrentoverlay"><a class="header" href="#lincegetcurrentoverlay">LinceGetCurrentOverlay</a></h2>
<pre><code class="language-c">LinceLayer* LinceGetCurrentOverlay()
</code></pre>
<p>Retrieves a pointer to the current active overlay.
If no overlay is active, returns NULL.
This is useful when you need to retrieve overlat data from within callbacks called on the overlays's OnUpdate and OnEvent functions.</p>
<h2 id="lincelayerstack"><a class="header" href="#lincelayerstack">LinceLayerStack</a></h2>
<p>Stack of layers that are updated from last to first.</p>
<ul>
<li><code>LinceLayer** layers</code>
<ul>
<li>Array of layer pointers which constitutes the stack.</li>
</ul>
</li>
<li><code>unsigned int count</code>
<ul>
<li>Number of layers in the stack.</li>
</ul>
</li>
</ul>
<h2 id="lincecreatelayerstack"><a class="header" href="#lincecreatelayerstack">LinceCreateLayerStack</a></h2>
<pre><code class="language-c">LinceLayerStack* LinceCreateLayerStack()
</code></pre>
<p>Allocates a new layer stack.</p>
<h2 id="lincedestroylayerstack"><a class="header" href="#lincedestroylayerstack">LinceDestroyLayerStack</a></h2>
<pre><code class="language-c">void LinceDestroyLayerStack(LinceLayerStack*)
</code></pre>
<p>Deletes all layers on the stack, calling their OnDetach callbacks in order.</p>
<h2 id="lincelayerstackpush"><a class="header" href="#lincelayerstackpush">LinceLayerStackPush</a></h2>
<pre><code class="language-c">void LinceLayerStackPush(LinceLayerStack*, LinceLayer*)
</code></pre>
<p>Appends a layer to the stack.</p>
<h2 id="lincelayerstackpop"><a class="header" href="#lincelayerstackpop">LinceLayerStackPop</a></h2>
<pre><code class="language-c">void LinceLayerStackPop(LinceLayerStack*, LinceLayer*)
</code></pre>
<p>Removes a layer from the stack.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input"><a class="header" href="#input">Input</a></h1>
<h2 id="linceiskeypressed"><a class="header" href="#linceiskeypressed">LinceIsKeyPressed</a></h2>
<pre><code class="language-c">LinceBool LinceIsKeyPressed(int key)
</code></pre>
<p>Returns <code>LinceTrue</code> if the given key is pressed.</p>
<h2 id="linceismousebuttonpressed"><a class="header" href="#linceismousebuttonpressed">LinceIsMouseButtonPressed</a></h2>
<pre><code class="language-c">LinceBool LinceIsMouseButtonPressed(int button)
</code></pre>
<p>Returns <code>LinceTrue</code> if the given mouse button is pressed.</p>
<h2 id="lincegetmousepos"><a class="header" href="#lincegetmousepos">LinceGetMousePos</a></h2>
<pre><code class="language-c">void LinceGetMousePos(float* xpos, float* ypos)
</code></pre>
<p>Returns the X and Y position of the mouse via the provided pointers. The position is in screen coordinates with origin on the top-left corner of the window.</p>
<h2 id="lincegetmousex"><a class="header" href="#lincegetmousex">LinceGetMouseX</a></h2>
<pre><code class="language-c">float LinceGetMouseX()
</code></pre>
<p>Returns the X position of the mouse.</p>
<h2 id="lincegetmousey"><a class="header" href="#lincegetmousey">LinceGetMouseY</a></h2>
<pre><code class="language-c">float LinceGetMouseY()
</code></pre>
<p>Returns the Y position of the mouse.</p>
<h2 id="lincekey"><a class="header" href="#lincekey">LinceKey</a></h2>
<p>Keycodes follow GLFW codes.</p>
<div class="table-wrapper"><table><thead><tr><th>Enum</th><th>Value</th><th>Key</th></tr></thead><tbody>
<tr><td>LinceKey_Unknown</td><td>-1</td><td></td></tr>
<tr><td>LinceKey_Space</td><td>32</td><td></td></tr>
<tr><td>LinceKey_Apostrophe</td><td>39</td><td>'</td></tr>
<tr><td>LinceKey_Comma</td><td>44</td><td>,</td></tr>
<tr><td>LinceKey_Minus</td><td>45</td><td>-</td></tr>
<tr><td>LinceKey_Period</td><td>46</td><td>.</td></tr>
<tr><td>LinceKey_Slash</td><td>47</td><td>/</td></tr>
<tr><td>LinceKey_0</td><td>48</td><td>0</td></tr>
<tr><td>LinceKey_1</td><td>49</td><td>1</td></tr>
<tr><td>LinceKey_2</td><td>50</td><td>2</td></tr>
<tr><td>LinceKey_3</td><td>51</td><td>3</td></tr>
<tr><td>LinceKey_4</td><td>52</td><td>4</td></tr>
<tr><td>LinceKey_5</td><td>53</td><td>5</td></tr>
<tr><td>LinceKey_6</td><td>54</td><td>6</td></tr>
<tr><td>LinceKey_7</td><td>55</td><td>7</td></tr>
<tr><td>LinceKey_8</td><td>56</td><td>8</td></tr>
<tr><td>LinceKey_9</td><td>57</td><td>9</td></tr>
<tr><td>LinceKey_Semicolon</td><td>59</td><td>;</td></tr>
<tr><td>LinceKey_Equal</td><td>61</td><td>=</td></tr>
<tr><td>LinceKey_a</td><td>65</td><td>a</td></tr>
<tr><td>LinceKey_b</td><td>66</td><td>b</td></tr>
<tr><td>LinceKey_c</td><td>67</td><td>c</td></tr>
<tr><td>LinceKey_d</td><td>68</td><td>d</td></tr>
<tr><td>LinceKey_e</td><td>69</td><td>e</td></tr>
<tr><td>LinceKey_f</td><td>70</td><td>f</td></tr>
<tr><td>LinceKey_g</td><td>71</td><td>g</td></tr>
<tr><td>LinceKey_h</td><td>72</td><td>h</td></tr>
<tr><td>LinceKey_i</td><td>73</td><td>i</td></tr>
<tr><td>LinceKey_j</td><td>74</td><td>j</td></tr>
<tr><td>LinceKey_k</td><td>75</td><td>k</td></tr>
<tr><td>LinceKey_l</td><td>76</td><td>l</td></tr>
<tr><td>LinceKey_m</td><td>77</td><td>m</td></tr>
<tr><td>LinceKey_n</td><td>78</td><td>n</td></tr>
<tr><td>LinceKey_o</td><td>79</td><td>o</td></tr>
<tr><td>LinceKey_p</td><td>80</td><td>p</td></tr>
<tr><td>LinceKey_q</td><td>81</td><td>q</td></tr>
<tr><td>LinceKey_r</td><td>82</td><td>r</td></tr>
<tr><td>LinceKey_s</td><td>83</td><td>s</td></tr>
<tr><td>LinceKey_t</td><td>84</td><td>t</td></tr>
<tr><td>LinceKey_u</td><td>85</td><td>u</td></tr>
<tr><td>LinceKey_v</td><td>86</td><td>v</td></tr>
<tr><td>LinceKey_w</td><td>87</td><td>w</td></tr>
<tr><td>LinceKey_x</td><td>88</td><td>x</td></tr>
<tr><td>LinceKey_y</td><td>89</td><td>y</td></tr>
<tr><td>LinceKey_z</td><td>90</td><td>z</td></tr>
<tr><td>LinceKey_LeftBracket</td><td>91</td><td>[</td></tr>
<tr><td>LinceKey_Backslash</td><td>92</td><td>\</td></tr>
<tr><td>LinceKey_RightBracket</td><td>93</td><td>]</td></tr>
<tr><td>LinceKey_GraveAccent</td><td>96</td><td>`</td></tr>
<tr><td>LinceKey_World1</td><td>161</td><td></td></tr>
<tr><td>LinceKey_World2</td><td>162</td><td></td></tr>
<tr><td>LinceKey_Escape</td><td>256</td><td></td></tr>
<tr><td>LinceKey_Enter</td><td>257</td><td></td></tr>
<tr><td>LinceKey_Tab</td><td>258</td><td></td></tr>
<tr><td>LinceKey_Backspace</td><td>259</td><td></td></tr>
<tr><td>LinceKey_Insert</td><td>260</td><td></td></tr>
<tr><td>LinceKey_Delete</td><td>261</td><td></td></tr>
<tr><td>LinceKey_Right</td><td>262</td><td></td></tr>
<tr><td>LinceKey_Left</td><td>263</td><td></td></tr>
<tr><td>LinceKey_Down</td><td>264</td><td></td></tr>
<tr><td>LinceKey_Up</td><td>265</td><td></td></tr>
<tr><td>LinceKey_PageUp</td><td>266</td><td></td></tr>
<tr><td>LinceKey_PageDown</td><td>267</td><td></td></tr>
<tr><td>LinceKey_Home</td><td>268</td><td></td></tr>
<tr><td>LinceKey_End</td><td>269</td><td></td></tr>
<tr><td>LinceKey_CapsLock</td><td>280</td><td></td></tr>
<tr><td>LinceKey_ScrollLock</td><td>281</td><td></td></tr>
<tr><td>LinceKey_NumLock</td><td>282</td><td></td></tr>
<tr><td>LinceKey_PrintScreen</td><td>283</td><td></td></tr>
<tr><td>LinceKey_Pause</td><td>284</td><td></td></tr>
<tr><td>LinceKey_F1</td><td>290</td><td></td></tr>
<tr><td>LinceKey_F2</td><td>291</td><td></td></tr>
<tr><td>LinceKey_F3</td><td>292</td><td></td></tr>
<tr><td>LinceKey_F4</td><td>293</td><td></td></tr>
<tr><td>LinceKey_F5</td><td>294</td><td></td></tr>
<tr><td>LinceKey_F6</td><td>295</td><td></td></tr>
<tr><td>LinceKey_F7</td><td>296</td><td></td></tr>
<tr><td>LinceKey_F8</td><td>297</td><td></td></tr>
<tr><td>LinceKey_F9</td><td>298</td><td></td></tr>
<tr><td>LinceKey_F10</td><td>299</td><td></td></tr>
<tr><td>LinceKey_F11</td><td>300</td><td></td></tr>
<tr><td>LinceKey_F12</td><td>301</td><td></td></tr>
<tr><td>LinceKey_F13</td><td>302</td><td></td></tr>
<tr><td>LinceKey_F14</td><td>303</td><td></td></tr>
<tr><td>LinceKey_F15</td><td>304</td><td></td></tr>
<tr><td>LinceKey_F16</td><td>305</td><td></td></tr>
<tr><td>LinceKey_F17</td><td>306</td><td></td></tr>
<tr><td>LinceKey_F18</td><td>307</td><td></td></tr>
<tr><td>LinceKey_F19</td><td>308</td><td></td></tr>
<tr><td>LinceKey_F20</td><td>309</td><td></td></tr>
<tr><td>LinceKey_F21</td><td>310</td><td></td></tr>
<tr><td>LinceKey_F22</td><td>311</td><td></td></tr>
<tr><td>LinceKey_F23</td><td>312</td><td></td></tr>
<tr><td>LinceKey_F24</td><td>313</td><td></td></tr>
<tr><td>LinceKey_F25</td><td>314</td><td></td></tr>
<tr><td>LinceKey_Kp0</td><td>320</td><td></td></tr>
<tr><td>LinceKey_Kp1</td><td>321</td><td></td></tr>
<tr><td>LinceKey_Kp2</td><td>322</td><td></td></tr>
<tr><td>LinceKey_Kp3</td><td>323</td><td></td></tr>
<tr><td>LinceKey_Kp4</td><td>324</td><td></td></tr>
<tr><td>LinceKey_Kp5</td><td>325</td><td></td></tr>
<tr><td>LinceKey_Kp6</td><td>326</td><td></td></tr>
<tr><td>LinceKey_Kp7</td><td>327</td><td></td></tr>
<tr><td>LinceKey_Kp8</td><td>328</td><td></td></tr>
<tr><td>LinceKey_Kp9</td><td>329</td><td></td></tr>
<tr><td>LinceKey_KpDecimal</td><td>330</td><td></td></tr>
<tr><td>LinceKey_KpDivide</td><td>331</td><td></td></tr>
<tr><td>LinceKey_KpMultiply</td><td>332</td><td></td></tr>
<tr><td>LinceKey_KpSubtract</td><td>333</td><td></td></tr>
<tr><td>LinceKey_KpAdd</td><td>334</td><td></td></tr>
<tr><td>LinceKey_KpEnter</td><td>335</td><td></td></tr>
<tr><td>LinceKey_KpEqual</td><td>336</td><td></td></tr>
<tr><td>LinceKey_LeftShift</td><td>340</td><td></td></tr>
<tr><td>LinceKey_LeftControl</td><td>341</td><td></td></tr>
<tr><td>LinceKey_LeftAlt</td><td>342</td><td></td></tr>
<tr><td>LinceKey_LeftSuper</td><td>343</td><td></td></tr>
<tr><td>LinceKey_RightShift</td><td>344</td><td></td></tr>
<tr><td>LinceKey_RightControl</td><td>345</td><td></td></tr>
<tr><td>LinceKey_RightAlt</td><td>346</td><td></td></tr>
<tr><td>LinceKey_RightSuper</td><td>347</td><td></td></tr>
<tr><td>LinceKey_Menu</td><td>348</td><td></td></tr>
<tr><td>LinceKey_Last</td><td>LinceKey_Menu</td><td></td></tr>
</tbody></table>
</div>
<h2 id="lincemousebutton"><a class="header" href="#lincemousebutton">LinceMouseButton</a></h2>
<p>Mouse button codes follow GLFW codes.</p>
<div class="table-wrapper"><table><thead><tr><th>Enum</th><th>Value</th></tr></thead><tbody>
<tr><td>LinceMouseButton_1</td><td>0</td></tr>
<tr><td>LinceMouseButton_2</td><td>1</td></tr>
<tr><td>LinceMouseButton_3</td><td>2</td></tr>
<tr><td>LinceMouseButton_4</td><td>3</td></tr>
<tr><td>LinceMouseButton_5</td><td>4</td></tr>
<tr><td>LinceMouseButton_6</td><td>5</td></tr>
<tr><td>LinceMouseButton_7</td><td>6</td></tr>
<tr><td>LinceMouseButton_8</td><td>7</td></tr>
<tr><td>LinceMouseButton_Last</td><td>LinceMouseButton_8</td></tr>
<tr><td>LinceMouseButton_Left</td><td>LinceMouseButton_1</td></tr>
<tr><td>LinceMouseButton_Right</td><td>LinceMouseButton_2</td></tr>
<tr><td>LinceMouseButton_Middle</td><td>LinceMouseButton_3</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rendering"><a class="header" href="#rendering">Rendering</a></h1>
<ol>
<li><a href="./Buffers.html">Buffers</a></li>
<li><a href="./VertexArrays.html">Vertex Arrays</a></li>
<li><a href="./Shaders.html">Shaders</a></li>
<li><a href="./Textures.html">Textures</a></li>
<li><a href="./Renderer.html">Renderer</a></li>
<li><a href="./Cameras.html">Cameras</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buffers"><a class="header" href="#buffers">Buffers</a></h1>
<p>Buffers are simply memory spaces where vertex data is passed onto OpenGL and stored.</p>
<h2 id="lincebuffertype"><a class="header" href="#lincebuffertype">LinceBufferType</a></h2>
<p>Describes the data type of elements in a buffer.
These are usually integers or floats, and arrays of these with fixed sizes, including square matrices.</p>
<div class="table-wrapper"><table><thead><tr><th>Enum</th><th>Value</th><th>Components</th><th>Bytes</th></tr></thead><tbody>
<tr><td>LinceBufferType_None</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>LinceBufferType_Bool</td><td>1</td><td>1</td><td>4</td></tr>
<tr><td>LinceBufferType_Int</td><td>2</td><td>1</td><td>4</td></tr>
<tr><td>LinceBufferType_Int2</td><td>3</td><td>2</td><td>8</td></tr>
<tr><td>LinceBufferType_Int3</td><td>4</td><td>3</td><td>12</td></tr>
<tr><td>LinceBufferType_Int4</td><td>5</td><td>4</td><td>16</td></tr>
<tr><td>LinceBufferType_Float</td><td>6</td><td>1</td><td>4</td></tr>
<tr><td>LinceBufferType_Float2</td><td>7</td><td>2</td><td>8</td></tr>
<tr><td>LinceBufferType_Float3</td><td>8</td><td>3</td><td>12</td></tr>
<tr><td>LinceBufferType_Float4</td><td>9</td><td>4</td><td>16</td></tr>
<tr><td>LinceBufferType_Mat3</td><td>10</td><td>9</td><td>36</td></tr>
<tr><td>LinceBufferType_Mat4</td><td>11</td><td>16</td><td>64</td></tr>
<tr><td>LinceBufferType_Count</td><td>12</td><td>--</td><td>--</td></tr>
</tbody></table>
</div>
<h2 id="lincebufferelement"><a class="header" href="#lincebufferelement">LinceBufferElement</a></h2>
<ul>
<li><code>LinceBufferType type</code></li>
<li><code>const char name[LINCE_NAME_MAX]</code></li>
<li><code>unsigned int gl_type</code></li>
<li><code>unsigned int comps</code></li>
<li><code>unsigned int bytes</code></li>
<li><code>unsigned int offset</code></li>
</ul>
<h2 id="lincegetbuffertypedata"><a class="header" href="#lincegetbuffertypedata">LinceGetBufferTypeData</a></h2>
<pre><code class="language-c">LinceBufferElement LinceGetBufferTypeData(LinceBufferType type)
</code></pre>
<h2 id="lincesetupbufferelementdata"><a class="header" href="#lincesetupbufferelementdata">LinceSetupBufferElementData</a></h2>
<pre><code class="language-c">void LinceSetupBufferElementData(LinceBufferElement* elem)
</code></pre>
<h2 id="lincevertexbuffer"><a class="header" href="#lincevertexbuffer">LinceVertexBuffer</a></h2>
<pre><code class="language-c">typedef unsigned int LinceVertexBuffer
</code></pre>
<h2 id="lincecreatevertexbuffer"><a class="header" href="#lincecreatevertexbuffer">LinceCreateVertexBuffer</a></h2>
<pre><code class="language-c">LinceVertexBuffer LinceCreateVertexBuffer(void* data, unsigned int size)
</code></pre>
<h2 id="lincesetvertexbufferdata"><a class="header" href="#lincesetvertexbufferdata">LinceSetVertexBufferData</a></h2>
<pre><code class="language-c">void LinceSetVertexBufferData(LinceVertexBuffer vb, void* data, unsigned int size)
</code></pre>
<h2 id="lincebindvertexbuffer"><a class="header" href="#lincebindvertexbuffer">LinceBindVertexBuffer</a></h2>
<pre><code class="language-c">void LinceBindVertexBuffer(LinceVertexBuffer vb)
</code></pre>
<h2 id="linceunbindvertexbuffer"><a class="header" href="#linceunbindvertexbuffer">LinceUnbindVertexBuffer</a></h2>
<pre><code class="language-c">void LinceUnbindVertexBuffer()
</code></pre>
<h2 id="lincedeletevertexbuffer"><a class="header" href="#lincedeletevertexbuffer">LinceDeleteVertexBuffer</a></h2>
<pre><code class="language-c">void LinceDeleteVertexBuffer(LinceVertexBuffer vb)
</code></pre>
<h2 id="linceindexbuffer"><a class="header" href="#linceindexbuffer">LinceIndexBuffer</a></h2>
<ul>
<li><code>unsigned int id</code></li>
<li><code>unsigned int count</code></li>
</ul>
<h2 id="lincecreateindexbuffer"><a class="header" href="#lincecreateindexbuffer">LinceCreateIndexBuffer</a></h2>
<pre><code class="language-c">LinceIndexBuffer LinceCreateIndexBuffer(unsigned int* data, unsigned int count)
</code></pre>
<h2 id="lincebindindexbuffer"><a class="header" href="#lincebindindexbuffer">LinceBindIndexBuffer</a></h2>
<pre><code class="language-c">void LinceBindIndexBuffer(LinceIndexBuffer ib)
</code></pre>
<h2 id="linceunbindindexbuffer"><a class="header" href="#linceunbindindexbuffer">LinceUnbindIndexBuffer</a></h2>
<pre><code class="language-c">void LinceUnbindIndexBuffer()
</code></pre>
<h2 id="lincedeleteindexbuffer"><a class="header" href="#lincedeleteindexbuffer">LinceDeleteIndexBuffer</a></h2>
<pre><code class="language-c">void LinceDeleteIndexBuffer(LinceIndexBuffer ib)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vertex-arrays"><a class="header" href="#vertex-arrays">Vertex Arrays</a></h1>
<h2 id="lincevertexarray"><a class="header" href="#lincevertexarray">LinceVertexArray</a></h2>
<ul>
<li><code>unsigned int id</code></li>
<li><code>LinceIndexBuffer index_buffer</code></li>
<li><code>LinceVertexBuffer vb_list</code></li>
<li><code>unsigned int vb_count</code></li>
</ul>
<h2 id="lincecreatevertexarray"><a class="header" href="#lincecreatevertexarray">LinceCreateVertexArray</a></h2>
<pre><code class="language-c">LinceVertexArray* LinceCreateVertexArray(LinceIndexBuffer index_buffer)
</code></pre>
<h2 id="lincebindvertexarray"><a class="header" href="#lincebindvertexarray">LinceBindVertexArray</a></h2>
<pre><code class="language-c">void LinceBindVertexArray(LinceVertexArray* vertex_array)
</code></pre>
<h2 id="linceunbindvertexarray"><a class="header" href="#linceunbindvertexarray">LinceUnbindVertexArray</a></h2>
<pre><code class="language-c">void LinceUnbindVertexArray(void)
</code></pre>
<h2 id="linceaddvertexarrayattributes"><a class="header" href="#linceaddvertexarrayattributes">LinceAddVertexArrayAttributes</a></h2>
<pre><code class="language-c">void LinceAddVertexArrayAttributes(
	LinceVertexArray* vertex_array,
	LinceVertexBuffer vertex_buffer,
	LinceBufferElement* layout,
	unsigned int layout_elements
)
</code></pre>
<h2 id="lincedeletevertexarray"><a class="header" href="#lincedeletevertexarray">LinceDeleteVertexArray</a></h2>
<pre><code class="language-c">void LinceDeleteVertexArray(LinceVertexArray* vertex_array)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shaders"><a class="header" href="#shaders">Shaders</a></h1>
<h2 id="linceshader"><a class="header" href="#linceshader">LinceShader</a></h2>
<ul>
<li><code>unsigned int id</code></li>
<li><code>char name[LINCE_NAME_MAX]</code></li>
<li><code>char **uniform_names</code></li>
<li><code>int *uniform_ids</code></li>
<li><code>unsigned int uniform_count</code></li>
</ul>
<h2 id="lincecreateshader"><a class="header" href="#lincecreateshader">LinceCreateShader</a></h2>
<pre><code class="language-c">LinceShader* LinceCreateShader(
	const char* name,
	const char* vertex_path,
	const char* fragment_path
)
</code></pre>
<p>Creates a shader object from vertex and fragment shader files and a string ID 'name'.</p>
<h2 id="lincecreateshaderfromsrc"><a class="header" href="#lincecreateshaderfromsrc">LinceCreateShaderFromSrc</a></h2>
<pre><code class="language-c">LinceShader* LinceCreateShaderFromSrc(
	const char* name,
	const char* vertex_src,
	const char* fragment_src
)
</code></pre>
<p>Creates a texture by providing the shader sources directly instead of loading them from files.</p>
<h2 id="lincebindshader"><a class="header" href="#lincebindshader">LinceBindShader</a></h2>
<pre><code class="language-c">void LinceBindShader(LinceShader* shader)
</code></pre>
<p>Uses the provided shader for rendering.</p>
<h2 id="linceunbindshader"><a class="header" href="#linceunbindshader">LinceUnbindShader</a></h2>
<pre><code class="language-c">void LinceUnbindShader(void)
</code></pre>
<p>Removes the shader currently bound (if any).</p>
<h2 id="lincedeleteshader"><a class="header" href="#lincedeleteshader">LinceDeleteShader</a></h2>
<pre><code class="language-c">void LinceDeleteShader(LinceShader* shader)
</code></pre>
<p>Frees the shader data.</p>
<h2 id="lincegetshaderuniformid"><a class="header" href="#lincegetshaderuniformid">LinceGetShaderUniformID</a></h2>
<pre><code class="language-c">int LinceGetShaderUniformID(LinceShader* shader, const char* name)
</code></pre>
<h2 id="lincesetshaderuniformint"><a class="header" href="#lincesetshaderuniformint">LinceSetShaderUniformInt</a></h2>
<pre><code class="language-c">void LinceSetShaderUniformInt(
	LinceShader* sh,
	const char* name,
	int val
)
</code></pre>
<h2 id="lincesetshaderuniformintn"><a class="header" href="#lincesetshaderuniformintn">LinceSetShaderUniformIntN</a></h2>
<pre><code class="language-c">void LinceSetShaderUniformIntN(
	LinceShader* sh,
	const char* name,
	int* arr,
	unsigned int count
)
</code></pre>
<h2 id="lincesetshaderuniformfloat"><a class="header" href="#lincesetshaderuniformfloat">LinceSetShaderUniformFloat</a></h2>
<pre><code class="language-c">void LinceSetShaderUniformFloat(
	LinceShader* sh,
	const char* name,
	float val
)
</code></pre>
<h2 id="lincesetshaderuniformvec2"><a class="header" href="#lincesetshaderuniformvec2">LinceSetShaderUniformVec2</a></h2>
<pre><code class="language-c">void LinceSetShaderUniformVec2(LinceShader* sh, const char* name, vec2 v)
</code></pre>
<h2 id="lincesetshaderuniformvec3"><a class="header" href="#lincesetshaderuniformvec3">LinceSetShaderUniformVec3</a></h2>
<pre><code class="language-c">void LinceSetShaderUniformVec3(LinceShader* sh, const char* name, vec3 v);
</code></pre>
<h2 id="lincesetshaderuniformvec4"><a class="header" href="#lincesetshaderuniformvec4">LinceSetShaderUniformVec4</a></h2>
<pre><code class="language-c">void LinceSetShaderUniformVec4(LinceShader* sh, const char* name, vec4 v);
</code></pre>
<h2 id="lincesetshaderuniformmat3"><a class="header" href="#lincesetshaderuniformmat3">LinceSetShaderUniformMat3</a></h2>
<pre><code class="language-c">void LinceSetShaderUniformMat3(LinceShader* sh, const char* name, mat3 m)
</code></pre>
<h2 id="lincesetshaderuniformmat4"><a class="header" href="#lincesetshaderuniformmat4">LinceSetShaderUniformMat4</a></h2>
<pre><code class="language-c">void LinceSetShaderUniformMat4(LinceShader* sh, const char* name, mat4 m);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="textures"><a class="header" href="#textures">Textures</a></h1>
<h2 id="lincetexture"><a class="header" href="#lincetexture">LinceTexture</a></h2>
<ul>
<li><code>uint32_t id</code></li>
<li><code>uint32_t width</code></li>
<li><code>uint32_t height</code></li>
<li><code>char name[LINCE_NAME_MAX]</code></li>
<li><code>int32_t data_format</code></li>
<li><code>int32_t internal_format</code></li>
</ul>
<h2 id="lincetextureflags"><a class="header" href="#lincetextureflags">LinceTextureFlags</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Enum</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>LinceTexture_Default</td><td>0x0</td><td>No modifications applied</td></tr>
<tr><td>LinceTexture_FlipY</td><td>0x1</td><td>Flips texture vertically on load</td></tr>
</tbody></table>
</div>
<h2 id="lincecreatetexture"><a class="header" href="#lincecreatetexture">LinceCreateTexture</a></h2>
<pre><code class="language-c">LinceTexture* LinceLoadTexture(const char* name, const char* path, uint32_t flags)
</code></pre>
<p>Loads a texture from a file at 'path', using a string 'name' as ID, and applies defined flags (see <code>LinceTextureFlags</code> above).</p>
<h2 id="lincecreatetexture-1"><a class="header" href="#lincecreatetexture-1">LinceCreateTexture</a></h2>
<pre><code class="language-c">LinceTexture* LinceCreateTexture(const char* name, const char* path)
</code></pre>
<p>Loads a texture from a file at 'path', using a string 'name' as ID.</p>
<h2 id="lincecreateemptytexture"><a class="header" href="#lincecreateemptytexture">LinceCreateEmptyTexture</a></h2>
<pre><code class="language-c">LinceTexture* LinceCreateEmptyTexture(
	const char* name, 
	uint32_t width,
	uint32_t height
)
</code></pre>
<p>Creates an empty texture of given size.</p>
<h2 id="lincesettexturedata"><a class="header" href="#lincesettexturedata">LinceSetTextureData</a></h2>
<pre><code class="language-c">void LinceSetTextureData(LinceTexture* texture, unsigned char* data)
</code></pre>
<p>Provides byte data to a texture, useful for empty textures.</p>
<h2 id="lincedeletetexture"><a class="header" href="#lincedeletetexture">LinceDeleteTexture</a></h2>
<pre><code class="language-c">void LinceDeleteTexture(LinceTexture* texture)
</code></pre>
<p>Frees texture data and deletes corresponding OpenGL object.</p>
<h2 id="lincebindtexture"><a class="header" href="#lincebindtexture">LinceBindTexture</a></h2>
<pre><code class="language-c">void LinceBindTexture(LinceTexture* texture, uint32_t slot)
</code></pre>
<p>Binds a texture to a slot so that it may be used in rendering.
Note that the total number of slots vary depending on platform, but is usually 32 on modern platforms.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="renderer"><a class="header" href="#renderer">Renderer</a></h1>
<h2 id="linceinitrenderer"><a class="header" href="#linceinitrenderer">LinceInitRenderer</a></h2>
<pre><code class="language-c">void LinceInitRenderer()
</code></pre>
<p>Initialises the rendering state: allocates vertex batch, initialises default shader and texture, etc.
This should be called only once. </p>
<h2 id="linceterminaterenderer"><a class="header" href="#linceterminaterenderer">LinceTerminateRenderer</a></h2>
<pre><code class="language-c">void LinceTerminateRenderer()
</code></pre>
<p>Frees allocated memory and destroys OpenGL objects.</p>
<h2 id="lincequadprops"><a class="header" href="#lincequadprops">LinceQuadProps</a></h2>
<p>This struct contains the information to render a &quot;quad&quot; (rectangle) on screen, such as location, size, and color.</p>
<ul>
<li><code>float x</code>
<ul>
<li>X-axis position in the world</li>
</ul>
</li>
<li><code>float y</code>
<ul>
<li>Y-axis position in the world</li>
</ul>
</li>
<li><code>float w</code>
<ul>
<li>Width, size in the x-axis.</li>
</ul>
</li>
<li><code>float h</code>
<ul>
<li>Height, size in the y-axis.</li>
</ul>
</li>
<li><code>float zorder</code>
<ul>
<li>Order for rendering overlapping quads. A higher number results in a quad being rendered above others.</li>
</ul>
</li>
<li><code>float rotation</code>
<ul>
<li>Clockwise rotation in degrees</li>
</ul>
</li>
<li><code>float color[4]</code>
<ul>
<li>RGBA color as floats with values between 0 and 1.</li>
</ul>
</li>
<li><code>LinceTexture* texture</code>
<ul>
<li>Texture to apply on the quad. If <code>NULL</code>, a default white texture is used instead.</li>
</ul>
</li>
<li><code>LinceTile* tile</code>
<ul>
<li>Renders only part of a texture. Overrides the <code>texture</code> parameter. See (Tiles)[./Tiles.md].</li>
</ul>
</li>
</ul>
<p>Note that for ease of use one may use a designated initialiser list, where an struct is initialised enclosed in curly brakets where specific fields are given values <code>{.x = 1, .y = 2}</code>.</p>
<p>Note that any field that is left uninitialised will be set to zero of the appropriate type. For instance, defining only the x position <code>{.x=1.0}</code> will make <code>y = 0</code> and the texture <code>NULL</code>, however it will also make the color completely transparent (<code>color = {0, 0, 0, 0}</code>, where alpha is zero) as well as the size (width and height) zero.</p>
<p>This example describes a red square at origin:</p>
<pre><code class="language-c">LinceQuadProps props = {
	.w=1.0, .h=1.0,
	.color={1.0,0.0,0.0,1.0}
};
</code></pre>
<h2 id="lincebeginscene"><a class="header" href="#lincebeginscene">LinceBeginScene</a></h2>
<pre><code class="language-c">void LinceBeginScene(LinceCamera* camera)
</code></pre>
<p>Prepares a new batch for rendering.</p>
<h2 id="linceendscene"><a class="header" href="#linceendscene">LinceEndScene</a></h2>
<pre><code class="language-c">void LinceEndScene()
</code></pre>
<p>Flushes the vertex batch and renders the geometry.</p>
<h2 id="lincedrawquad"><a class="header" href="#lincedrawquad">LinceDrawQuad</a></h2>
<pre><code class="language-c">void LinceDrawQuad(LinceQuadProps props)
</code></pre>
<p>Submits a quad (rectangle) for rendering. This function should only be called between <code>LinceBeginScene</code> and <code>LinceEndScene</code> calls.</p>
<p>This example below shows how to use the rendering API to render quads to the screen. This code snippet should be placed on your <code>OnUpdate</code> function and should be called every frame.</p>
<pre><code class="language-c">LinceBeginScene(camera);

LinceDrawQuad((LinceQuadProps){
	.w = 1.0, .h = 1.0,
	.color = {1.0, 0.0, 0.0, 1.0}
});

LinceEndScene();
</code></pre>
<h2 id="lincedrawindexed"><a class="header" href="#lincedrawindexed">LinceDrawIndexed</a></h2>
<pre><code class="language-c">void LinceDrawIndexed(
	LinceShader* shader,
	LinceVertexArray* va,
	LinceIndexBuffer vb
)
</code></pre>
<p>Mannually renders geometry with provided OpenGL objects.</p>
<h2 id="linceclear"><a class="header" href="#linceclear">LinceClear</a></h2>
<pre><code class="language-c">void LinceClear()
</code></pre>
<p>Clears the screen.</p>
<h2 id="lincesetclearcolor"><a class="header" href="#lincesetclearcolor">LinceSetClearColor</a></h2>
<pre><code class="language-c">void LinceSetClearColor(float r, float g, float b, float a)
</code></pre>
<p>Sets the color to which the screen is cleared.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cameras"><a class="header" href="#cameras">Cameras</a></h1>
<p>Cameras display the world of the game as well as provide the means to move within it, translating the location, shape, and color of game objects into your screen.</p>
<h2 id="lincecamera"><a class="header" href="#lincecamera">LinceCamera</a></h2>
<p>These fields may be modified by the user to change the camera's view of the world:</p>
<ul>
<li><code>float scale</code></li>
<li><code>float zoom</code>
<ul>
<li>Zoom value of the camera, where a greater value translates to zooming in.</li>
</ul>
</li>
<li><code>float rotation</code>
<ul>
<li>Clockwise rotation of the camera in degrees.</li>
</ul>
</li>
<li><code>vec3 pos</code>
<ul>
<li>Position of the camera in the world</li>
</ul>
</li>
</ul>
<p>These fields are internal and are automatically updated with the functions provided below.</p>
<ul>
<li><code>mat4 proj</code>
<ul>
<li>Projection matrix that calculates what objects are seen by the camera.</li>
</ul>
</li>
<li><code>mat4 view</code>
<ul>
<li>View matrix that translates the camera's eye to a flat screen view.</li>
</ul>
</li>
<li><code>mat4 view_proj</code>
<ul>
<li>View-projection matrix, calculated by multiplying the view and projection.</li>
</ul>
</li>
<li><code>mat4 view_proj_inv</code>
<ul>
<li>Inverse view-projection matrix.</li>
</ul>
</li>
<li><code>float aspect_ratio</code>
<ul>
<li>Aspect ratio of the window. Using an incorrect value will result in a distorted view of the world.</li>
</ul>
</li>
</ul>
<h2 id="lincecalculateprojection"><a class="header" href="#lincecalculateprojection">LinceCalculateProjection</a></h2>
<pre><code class="language-c">void LinceCalculateProjection(
	mat4 result,
	float left, float right,
	float bottom, float top
)
</code></pre>
<p>Calculates the projection matrix given the dimensions of the frustrum: left, right, bottom, and top. The near and far coordinates are hard coded as -1 and 1, respectively. This means that z values outside this range are not rendered.</p>
<h2 id="lincecreatecamera"><a class="header" href="#lincecreatecamera">LinceCreateCamera</a></h2>
<pre><code class="language-c">LinceCamera* LinceCreateCamera(float aspect_ratio)
</code></pre>
<p>Creates a new camera by calcualting the projection matrix from the window's aspect ratio.</p>
<h2 id="lincecreatecamerafromproj"><a class="header" href="#lincecreatecamerafromproj">LinceCreateCameraFromProj</a></h2>
<pre><code class="language-c">LinceCamera* LinceCreateCameraFromProj(mat4 proj)
</code></pre>
<p>Creates a new camera using a custom provided projection matrix.</p>
<h2 id="lincesetcameraproj"><a class="header" href="#lincesetcameraproj">LinceSetCameraProj</a></h2>
<pre><code class="language-c">void LinceSetCameraProj(LinceCamera* cam, mat4 proj)
</code></pre>
<p>Manually updates the projection matrix of an existing camera with the provided one.</p>
<h2 id="linceupdatecamera"><a class="header" href="#linceupdatecamera">LinceUpdateCamera</a></h2>
<pre><code class="language-c">void LinceUpdateCamera(LinceCamera* cam)
</code></pre>
<p>Recalculates the view-projection matrix using the values for scale, zoom, and rotation.</p>
<h2 id="linceresizecameraview"><a class="header" href="#linceresizecameraview">LinceResizeCameraView</a></h2>
<pre><code class="language-c">void LinceResizeCameraView(LinceCamera* cam, float aspect_ratio)
</code></pre>
<p>Updates the view matrix using the provided aspect ratio. This function should be called when the window is resized. </p>
<h2 id="lincedeletecamera"><a class="header" href="#lincedeletecamera">LinceDeleteCamera</a></h2>
<pre><code class="language-c">void LinceDeleteCamera(LinceCamera* cam)
</code></pre>
<p>Frees allocated camera data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui"><a class="header" href="#ui">UI</a></h1>
<p>The Lince engine uses Nuklear for its graphical user interface. See <a href="https://github.com/Immediate-Mode-UI/Nuklear/">the gihub repo</a> for detailed documentation. This document will compile useful Nuklear functions as well a Lince wrappers.</p>
<p>Any of Nuklear's window functions (anything between and including <code>nk_begin</code> and <code>nk_end</code>) can be used on the <code>OnUpdate</code> callbacks of any given layer. See <a href="./Layers.html">Layers.md</a> for a descriptopn on how to use layers in Lince. </p>
<p>Example:</p>
<pre><code class="language-c">void MyLayerOnUpdate(LinceLayer* layer, float dt){
	struct nk_context *ctx = LinceGetAppState()-&gt;ui-&gt;ctx;

	if (nk_begin(ctx, &quot;Demo&quot;, nk_rect(50, 50, 230, 250),
        NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_SCALABLE|
        NK_WINDOW_MINIMIZABLE|NK_WINDOW_TITLE
    )) {
		nk_layout_row_static(ctx, 30, 80, 1);
        if (nk_button_label(ctx, &quot;button&quot;)){
			printf(&quot;button pressed\n&quot;);
		}
	}
	nk_end(ctx);
}
</code></pre>
<h2 id="linceuilayer"><a class="header" href="#linceuilayer">LinceUILayer</a></h2>
<p>Wrapper that saves Nuklear's context and its GLFW rendering state.</p>
<ul>
<li><code>struct nk_context *ctx</code></li>
<li><code>void *glfw</code></li>
<li><code>void *glfw_window</code></li>
<li><code>struct nk_font* fonts[LinceFont_Count]</code></li>
</ul>
<h2 id="lincefonts"><a class="header" href="#lincefonts">LinceFonts</a></h2>
<p>Enum that offers a handy way to obtain a preloaded Nuklear font.
The values serve as an index for the array <code>app-&gt;ui-&gt;fonts</code> which holds pointers to all preloaded fonts.
The number next to the enum name indicates the font size, e.g. <code>LinceFont_Droid20</code> indexes the Droid font with font size 20.</p>
<div class="table-wrapper"><table><thead><tr><th>Enum</th><th>Value</th></tr></thead><tbody>
<tr><td>LinceFont_Droid15</td><td>0</td></tr>
<tr><td>LinceFont_Droid20</td><td>1</td></tr>
<tr><td>LinceFont_Droid30</td><td>2</td></tr>
<tr><td>LinceFont_Droid50</td><td>3</td></tr>
<tr><td>LinceFont_Count</td><td>4</td></tr>
</tbody></table>
</div>
<p>Example on how to retrieve a preloaded font:</p>
<pre><code class="language-c">void MyLayerOnUpdate(LinceLayer* layer, float dt){
	LinceApp* app = LinceGetAppState();
	struct nk_font* title_font = app-&gt;ui-&gt;fonts[LinceFont_Droid50];
	nk_style_set_font(app-&gt;ui-&gt;ctx, &amp;title_font-&gt;handle);
}
</code></pre>
<h2 id="linceuitext"><a class="header" href="#linceuitext">LinceUIText</a></h2>
<pre><code class="language-c">void LinceUIText(
    LinceUILayer* ui,
    const char* name,
    float x,
	float y,
    LinceFonts font, 
    size_t max_size, 
    const char* text,
    ...
)
</code></pre>
<p>Wrapper function that renders plain text to the screen.
Parameters:</p>
<ul>
<li><code>LinceUILayer* ui</code>
<ul>
<li>UI state, this can be retrieved from the application state <code>LinceGetAppState()-&gt;ui</code>.</li>
</ul>
</li>
<li><code>const char* name</code>
<ul>
<li>Unique string identifier for the Nuklear window.</li>
</ul>
</li>
<li><code>float x</code>
<ul>
<li>X position of the text in pixels, measured from the left-end of the text box.</li>
</ul>
</li>
<li><code>float y</code>
<ul>
<li>Y position of the text in pixels, measred from the top of the text box.</li>
</ul>
</li>
<li><code>LinceFonts font</code>
<ul>
<li>Font and font size to use. See below for available fonts.</li>
</ul>
</li>
<li><code>size_t max_size</code>
<ul>
<li>Maximum number of characters to display.</li>
</ul>
</li>
<li><code>const char* text, ...</code>
<ul>
<li>String to render. This may be formatted using <code>printf</code> conventions and additional variadic arguments.</li>
</ul>
</li>
</ul>
<p>This example renders the current delta-time and FPS to the upper left corner of the screen:</p>
<pre><code class="language-c">void MyLayerOnUpdate(LinceLayer* layer, float dt){

	LinceUILayer* ui = LinceGetAppState()-&gt;ui;

	/*          ui,  identifier,     x,  y,  font,              max, text,       format varargs */
	LinceUIText(ui, &quot;FPS_indicator&quot;, 10, 10, LinceFont_Droid30, 10,  &quot;FPS %.0f&quot;, 1000.0/dt);
    LinceUIText(ui, &quot;DT_indicator&quot;,  10, 40, LinceFont_Droid30, 10,  &quot;%.2f ms&quot;,  dt);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tiles"><a class="header" href="#tiles">Tiles</a></h1>
<h2 id="lincetile"><a class="header" href="#lincetile">LinceTile</a></h2>
<ul>
<li><code>LinceTexture* texture</code>
<ul>
<li>Preloaded texture object (see <a href="./Textures.html">Textures</a>)</li>
</ul>
</li>
<li><code>vec2 pos</code>
<ul>
<li>Location of the tile in units of cells</li>
</ul>
</li>
<li><code>vec2 cellsize</code>
<ul>
<li>Size of a cell in pixels</li>
</ul>
</li>
<li><code>vec2 tilesize</code>
<ul>
<li>Size of tile in units of cells</li>
</ul>
</li>
<li><code>float coords[8]</code>
<ul>
<li>Texture coordinates</li>
</ul>
</li>
</ul>
<h2 id="lincegettile"><a class="header" href="#lincegettile">LinceGetTile</a></h2>
<pre><code class="language-c">LinceTile LinceGetTile(LinceTexture* texture, vec2 pos, vec2 cellsize, vec2 tilesize)
</code></pre>
<p>This function calculates the texture coordinates of a tile within a texture,
and returns the results packaged in a <code>LinceTile</code> structure along with the input parameters used to calculate it (see above).
This object may later be passed to the <code>tile</code> argument of <code>LinceQuadProps</code> on the 2D renderer to render the desired tile only (see <a href="./Renderer.html">Renderer</a>).</p>
<p>Example code:</p>
<pre><code class="language-c">
LinceTexture* atlas = LinceCreateTexture(&quot;atlas&quot;, &quot;outdoors.png&quot;);

LinceTile tile_grass = LinceGetTile(
	atlas,
	(vec2){0,0},	// location 0,0 from lower left corner
	(vec2){16,16},	// a tile/cell is 16x16 pixels
	(vec2){1,1}		// the tile is 1x1 cells in size (16x16)
)
</code></pre>
<h2 id="lincetileanim"><a class="header" href="#lincetileanim">LinceTileAnim</a></h2>
<p>Stores the data to run tile-based sprite animations.</p>
<p>Required input data</p>
<ul>
<li><code>LinceTile* frames</code>
<ul>
<li>Buffer than contains tile array</li>
</ul>
</li>
<li><code>uint32_t frame_count</code>
<ul>
<li>Number of tiles in the buffer</li>
</ul>
</li>
<li><code>float frame_time</code>
<ul>
<li>Time in ms between frames</li>
</ul>
</li>
</ul>
<p>Optional parameters</p>
<ul>
<li><code>uint32_t start</code>
<ul>
<li>Tile index at which to start the animation</li>
</ul>
</li>
<li><code>uint32_t repeats</code>
<ul>
<li>Number of repeats to animate. If set to zero, it will repeat forever</li>
</ul>
</li>
<li><code>uint32_t* order</code>
<ul>
<li>Array if indices - order in which to render the tiles. If set, <code>start</code> index refers to an element of the order array</li>
</ul>
</li>
<li><code>uint32_t order_count</code>
<ul>
<li>Number of indices in the order array</li>
</ul>
</li>
<li><code>LinceTileAnimFn* on_finish</code>
<ul>
<li>Called when animation has finished. Signature <code>void callback(LinceTileAnim* anim, void* args)</code>.</li>
</ul>
</li>
<li><code>LinceTileAnimFn* on_repeat</code>
<ul>
<li>Called when animation loops over. Signature <code>void callback(LinceTileAnim* anim, void* args)</code>.</li>
</ul>
</li>
<li><code>void* callback_args</code>
<ul>
<li>Arguments to pass onto callbacks</li>
</ul>
</li>
<li><code>LinceTileAnimFlags flags</code>
<ul>
<li>Further settings as bit flags. Unused parameter.</li>
</ul>
</li>
</ul>
<p>Internal data</p>
<ul>
<li><code>float time</code>
<ul>
<li>Countdown until next frame</li>
</ul>
</li>
<li><code>uint32_t current_frame</code>
<ul>
<li>Index of current frame</li>
</ul>
</li>
<li><code>LinceTile* current_tile</code>
<ul>
<li>Pointer to current tile in the buffer</li>
</ul>
</li>
<li><code>uint32_t repeat_count</code>
<ul>
<li>Number of times the animation has been looped</li>
</ul>
</li>
<li><code>LinceBool finished</code>
<ul>
<li>Indicates whether animation has finished running</li>
</ul>
</li>
</ul>
<h2 id="lincecreatetileanim"><a class="header" href="#lincecreatetileanim">LinceCreateTileAnim</a></h2>
<pre><code class="language-c">LinceTileAnim* LinceCreateTileAnim(const LinceTileAnim* anim)
</code></pre>
<p>Initialises the animation. The user-defined settings and data are passed as a <code>LinceTileAnim</code> struct itself, which is then copied over to heap-allocated memory and returned to the user.</p>
<h2 id="linceupdatetileanim"><a class="header" href="#linceupdatetileanim">LinceUpdateTileAnim</a></h2>
<pre><code class="language-c">void LinceUpdateTileAnim(LinceTileAnim* anim, float dt)
</code></pre>
<p>Advaces the animation by time <code>dt</code> in milliseconds.</p>
<h2 id="linceresettileanim"><a class="header" href="#linceresettileanim">LinceResetTileAnim</a></h2>
<pre><code class="language-c">void LinceResetTileAnim(LinceTileAnim* anim)
</code></pre>
<p>Resets the animation back to its original point.</p>
<h2 id="lincedeletetileanim"><a class="header" href="#lincedeletetileanim">LinceDeleteTileAnim</a></h2>
<pre><code class="language-c">void LinceDeleteTileAnim(LinceTileAnim* anim)
</code></pre>
<p>Frees allocated animation data.</p>
<p>Code example:</p>
<pre><code class="language-c">
/* OnLayerCreate */
uint32_t count;
LinceTile* tiles = LoadTilesFromTexture(&quot;player-movement.png&quot;, &amp;count);
// the function above is an example

LinceTileAnim* anim = LinceCreateTileAnim(&amp;(LinceTileAnim){
	.frames = tiles,
	.frame_count = count,
	.frame_time = 100.0f // milliseconds
});


/* OnLayerUpdate */
LinceBeginScene(camera);
LinceUpdateAnim(anim);
LinceDrawQuad((LinceQuadProps){
	.w = 1.0, .h = 1.0,
	.color = {0.0, 0.0, 0.0, 1.0},
	.tile = anim-&gt;current_tile;
});
LinceEndScene();

/* OnLayerDestroy */
LinceDeleteAnim(anim);

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-diary"><a class="header" href="#development-diary">Development Diary</a></h1>
<h2 id="12-aug-2022"><a class="header" href="#12-aug-2022">12 Aug 2022</a></h2>
<p>I have been working on the idea of a tilemap editor. I have simply setup a Nuklear GUI element with a grid of buttons and images where each is a tile from the tileset. Click events on these buttons save your tile choice, and then click events on the tilemap itself swap the old tile with the new one. These changes are not saved to disk, and the tilemap is reset each time you close the application. Regardless, this is a good start!</p>
<p>One problem I am facing is that the tile images rendered by Nuklear are flipped on their Y axis, which makes it harder to work with them.</p>
<p>But before I go on to implement this editor, I first need to figure out what features tilemaps will have:</p>
<ol>
<li>Plain ground tiles (Implemented)</li>
<li>Overlay tiles with sorted z (Implemented)</li>
<li>Special tiles, e.g. doors, warps, animated tiles...</li>
</ol>
<p>Next steps to build this tilemap editor:</p>
<ol>
<li>Create separate folder and Premake5 project</li>
<li>Move the code over to the new project</li>
<li>Figure out a serialization system for tilemaps</li>
<li>Add create, save, and load functionality.</li>
</ol>
<p>I'm thinking the serialization will consist on two files: a ground data file (array of ground tile indices and bit flags) and a metadata file (tileset name, location of overlays and special tiles, etc).</p>
<h2 id="11-aug-2022"><a class="header" href="#11-aug-2022">11 Aug 2022</a></h2>
<p>Now that tile animations are setup, I'm moving onto tilemaps.
I have already made a bare-bones tilemap on the testing layer by loading a texture atlas, collecting some of its tiles in a separate tile array and addressing them using an enum. Then, I made a 2D array that stores indices of which tile to use, which constitutes the tilemap. A tilemap struct and API should simply cover these features.
Further features the tilemap should have are collision data, overlay tiles that are rendered over the player, doors and warps, etc.</p>
<p>Regarding these overlays (trees, etc), these in some cases must be drawn <strong>over</strong> the player, for instance when the player is standing behind. Drawing some quads over others can be achieved by changing their relative z coordinates. In the case of trees and other overlaid tiles, their <code>z</code> values must be greater than the player's when the player is behind them, and the opposite when the player is in front. This relation can be obtained in a purely arithmetic manner by calculating the <code>z</code> value of each quad based on their <code>y</code> coordinate: quads at higher <code>y</code> positions have lower <code>z</code> values because they are further away.</p>
<p>Finally, I will leave the exact serialization format for tilemaps for later development, along with the design of a future tilemap editor.</p>
<h2 id="10-aug-2022"><a class="header" href="#10-aug-2022">10 Aug 2022</a></h2>
<p>After a three-month long hiatus, and developing the 2D renderer as well as two simple games on the engine (Pong and Missile Command), I am now developing tile-based sprite animations. The way it works is you take an array of tiles, and you loop through them, with a countdown in between. The chosen 'frame' at any given time is provided as a quad texture and rendered.</p>
<p>Perhaps the most common example of sprite animations is a character walking, which is why I decied to implement it and why I found out that my implementation is too simple, not flexible enough. Walking in a 2D ground requires a total of eight animations: both walking and idle for left, right, front, and back directions. Using the simple tile-looping model, I had to create eight different animations off the same spritesheet, which is wasteful and resulted in too much boilerplate. But this could be simpler. I have been toying with the idea of providing the animation data with additional logic: the order in with the tiles are animated. This way, I wouldn't need eight separate animations, but only one. I can give it the entire spritesheet, and then make it use a subset of the tiles in a specific order for each of the character animations. Then, I would switch this subset of indices for another when the character's direction changes.</p>
<p><strong>Update</strong>: it worked! It's easiest when all the animations have the same number of frames. If not, you'll have to reallocate the order array for more/less space, which is slower.</p>
<h2 id="29-apr-2022"><a class="header" href="#29-apr-2022">29 Apr 2022</a></h2>
<p>Planning the shader API. I'm not sure what data structure to use for shader uniforms, which hold a string name and an OpenGL location integer ID. On the C++ code, an object like <code>std::unordered_map&lt;std::string, int&gt;</code> was used, and an equivalent C implementation is not so simple to implement. A simple implementation would store a list of string names (the shader uniform variable names) as well as another list of the same length with the location IDs. When an uniform set, the function searches for the uniform name in the list (either with string comparison or by hashing and comparing integer values); then it either changes its value if it exists, or creates a new uniform if it doesn't. I think I might just implement a string comparison for value searching, and then implement a more advanced algorithm later on.</p>
<h2 id="27-apr-2022"><a class="header" href="#27-apr-2022">27 Apr 2022</a></h2>
<p>Having updated the API to be more C-like, I have now moved to expanding it. The best course of action is to get a simple square rendered on the screen to check that the system is indeed working as expected. After solving a couple of headache-inducing bugs, I got a multi-coloured square on screen, and followed that up with an API for managing vertex arrays and buffer layouts. Next steps are the the shader and renderer2D API, and perhaps, a camera API, which will include matrix math.</p>
<h2 id="23-apr-2022"><a class="header" href="#23-apr-2022">23 Apr 2022</a></h2>
<p>So far, this project has been an attemt at recreating the C++ game engine built by TheCherno on his youtube series, but in C. Naturally, many of the features C++ has don't exist in C. This ended up making this C code look more OOP-like than procedural. My now goal is to build a simple game engine using procedural programming.</p>
<p>This migration will be carried out by following these steps:</p>
<ul>
<li>Renaming API functions, e.g. &quot;LinceApp_OnEvent&quot;, which refers to an object &quot;App&quot;, to &quot;LinceOnEvent&quot;, since there it's a general function called when any event takes place during runtime.</li>
<li>Simplify event and callback systems</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="to-do"><a class="header" href="#to-do">To Do</a></h1>
<h2 id="symbol-legend"><a class="header" href="#symbol-legend">Symbol legend</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Meaning</th></tr></thead><tbody>
<tr><td>✅</td><td>Completed</td></tr>
<tr><td>💛</td><td>In-dev</td></tr>
<tr><td>🟠</td><td>Delayed</td></tr>
<tr><td>🔷</td><td>Planned</td></tr>
</tbody></table>
</div>
<h2 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h2>
<ol>
<li>Basic 2D Renderer ✅
<ol>
<li>Vertex Arrays ✅</li>
<li>Shaders ✅</li>
<li>Textures ✅</li>
<li>Cameras ✅</li>
<li>Renderer2D API ✅</li>
</ol>
</li>
<li>Renderer Improvements ✅
<ol>
<li>Batch renderer ✅</li>
</ol>
</li>
<li>Tiles 💛
<ol>
<li>Tilesets and texture atlases ✅</li>
<li>Tile animations 💛</li>
<li>Tilemaps 💛</li>
</ol>
</li>
<li>Audio 🔷
<ol>
<li>Integrate OpenAL</li>
<li>Build audio API</li>
</ol>
</li>
</ol>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<ol>
<li>💛 Embed engine resources within the code (e.g. default shaders and textures)</li>
<li>🟠 Create test suite for the engine</li>
<li>🟠 Improve documentation - perhaps move to a separate github repo.</li>
<li>🔷 Restructure engine to be in a separate folder, that can be included into the user's main game project.</li>
<li>💛 Add benchmarking and identify slowest pieces of code that can be optimized.</li>
<li>🔷 Improve code speed &amp; efficiency, e.g. place shader uniforms in a key-value map</li>
</ol>
<h2 id="data"><a class="header" href="#data">Data</a></h2>
<ol>
<li>🔷 Add data structures, e.g. linked lists, hashmaps, etc. </li>
</ol>
<h2 id="audio"><a class="header" href="#audio">Audio</a></h2>
<ol>
<li>🔷 Integrate an audio library into the project (OpenAL or simpler library)</li>
</ol>
<h2 id="physics"><a class="header" href="#physics">Physics</a></h2>
<ol>
<li>💛 Add simple box colliders and algorithm to check</li>
</ol>
<h2 id="scenes"><a class="header" href="#scenes">Scenes</a></h2>
<ol>
<li>🔷 Add static and parallax backgrounds</li>
<li>🔷 Create scenes which can hold quads, and different scenes represent different screens/menus, etc. E.g. LinceScene, LinceScenePushQuad, LinceDrawScene, etc.</li>
<li>✅ <code>LinceLoadTexture</code> function that takes extra flags, such as flipping on the Y axis.</li>
</ol>
<h2 id="tile-system"><a class="header" href="#tile-system">Tile System</a></h2>
<ol>
<li>✅ <strong>Develop tile-based sprite animations</strong></li>
<li>✅ <strong>Improve tile animations with callbacks and custom tile order</strong></li>
<li>💛 Add tilemaps</li>
</ol>
<h2 id="2d-renderer"><a class="header" href="#2d-renderer">2D Renderer</a></h2>
<ol>
<li>✅ <strong>Add basic 2D renderer using immediate-mode scenes and quads</strong></li>
<li>✅ <strong>Add batching to 2D renderer</strong></li>
<li>✅ <strong>Add z-order with transparency support</strong></li>
<li>🟠 Add z-order with translucency support</li>
<li>✅ <strong>Move renderer initialisation and termination to the engine, away from the user</strong></li>
</ol>
<h2 id="gui"><a class="header" href="#gui">GUI</a></h2>
<ol>
<li>✅ <strong>Add Nuklear to project with appropriate backend</strong></li>
<li>✅ <strong>Add Nuklear layer and render GUI</strong></li>
<li>✅ <strong>Sort out issues with event callbacks and GLFW user pointer</strong></li>
<li>✅ <strong>Stop Nuklear API from exposing GLFW and OpenGL API to the user</strong></li>
<li>✅ <strong>Move Nuklear rendering layer to the engine</strong></li>
<li>🔷 Provide UI callback to layers</li>
<li>🟠 Improve LinceUIText</li>
</ol>
<h2 id="api-ease-of-use"><a class="header" href="#api-ease-of-use">API ease of use</a></h2>
<ol>
<li>💛 Add more user settings prior to calling <code>LinceRun</code></li>
<li>🟠 Add <code>LinceLoadTexture</code> function with an extra argument for flags, i.e. flipping by the y axis on load.</li>
<li>🟠 Add memory management functions, e.g. LinceMalloc, LinceNewCopy, etc</li>
</ol>
<h2 id="bugs"><a class="header" href="#bugs">Bugs</a></h2>
<ol>
<li>✅ <strong>(Solved)</strong> Missile Command: some quads persist on the screen</li>
<li>🟠 Draw text overlay without consuming click events</li>
</ol>
<h2 id="next-goals"><a class="header" href="#next-goals">Next goals</a></h2>
<ol>
<li>💛 Add UI library: <a href="https://github.com/Immediate-Mode-UI/Nuklear/">Nuklear</a></li>
<li>💛 Add tilesets</li>
<li>🔷 Add tilemaps</li>
<li>🔷 Make small games to test the engine</li>
<li>🔷 Make a tilemap editor</li>
<li>🔷 Add audio library, e.g. <a href="https://github.com/mackron/miniaudio">Miniaudio</a></li>
</ol>
<h2 id="extrarecurrent-goals"><a class="header" href="#extrarecurrent-goals">Extra/recurrent goals</a></h2>
<ol>
<li>🟠 Improve documentation</li>
<li>🟠 Add tests</li>
<li>🟠 Add logging</li>
<li>🟠 Fix issues with compiling on Windows</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="version-history"><a class="header" href="#version-history">Version History</a></h1>
<p>Version codes follow <a href="https://semver.org/">Semantic Versioning</a>.</p>
<ul>
<li>To-do:
logging
data structures
tests
docs</li>
</ul>
<h2 id="v042"><a class="header" href="#v042">v0.4.2</a></h2>
<ul>
<li>Added benchmarking and profiling tools in Python</li>
<li>Added basic test framework</li>
<li>Added hashmap, array, and linked list containers</li>
<li>Added caching of shader uniform locations with hashmap</li>
</ul>
<h2 id="v041"><a class="header" href="#v041">v0.4.1</a></h2>
<ul>
<li>Added function <code>LinceLoadTexture</code>, similar to <code>LinceCreateTexture</code> but with extra <code>flags</code> argument.</li>
<li>Added texture flag to flip texture data vertically on load <code>LinceTexture_FlipY</code>.</li>
<li>Updated docs</li>
<li>Fixed bug where Nuklear would respond to all scrolling events, even if no widget was active.</li>
<li>Embedded the renderer's shader source in the code, and removed the source files.</li>
</ul>
<h2 id="v040"><a class="header" href="#v040">v0.4.0</a></h2>
<ul>
<li>Added simple tilemaps - <code>LinceTilemap</code></li>
<li>Simplified premake5 script somewhat</li>
<li>Refactored Missile Command debug text as a movable and minimizable Nuklear window, as the text boxes where consuming the click events</li>
<li>Added memory management functions: LinceMalloc, LinceNewCopy, etc</li>
<li>Added allocation macros allowing for custom allocation functions - <code>LINCE_MALLOC</code>, <code>LINCE_CALLOC</code>, <code>LINCE_REALLOC</code>, and <code>LINCE_FREE</code></li>
<li>Added <code>LinceForeach</code> macro for iterating over array items</li>
<li>Added calculation for z-order based on the y coordinate <code>LinceYSortedZ</code></li>
</ul>
<h2 id="v031"><a class="header" href="#v031">v0.3.1</a></h2>
<ul>
<li>Renamed and moved the 2D renderer shader files to 'engine/assets/shaders'</li>
<li>Updated premake5 lua script</li>
<li>Moved Pong and Missile Command to their own projects and folders</li>
<li>Solved bug in Missile Command where texture would be freed twice</li>
<li>Updated docs</li>
</ul>
<h2 id="v030"><a class="header" href="#v030">v0.3.0</a></h2>
<ul>
<li>Added calculation of inverse view-projection matrix on camera update.</li>
<li>Added transform from screen to world coordinates.</li>
<li>Added function to retrieve screen size directly.</li>
<li>Added function to retrieve mouse position in world coordinates.</li>
<li>Solved bug where Nuklear UI events were not being flagged as handled.</li>
<li>Moved tile animation and tileset headers to 'tiles' folder.</li>
<li>Added tile animation and tileset headers to <code>lince.h</code>.</li>
<li>Renamed 'lince' folder to 'engine'.</li>
<li>Added assertion to ensure fonts are correctly loaded from file.</li>
<li>Moved engine source to 'lince' folder within 'engine/src'.</li>
<li>Fixed bug in 2D renderer where quads that were no longer being rendered persisted in the scene.</li>
</ul>
<h2 id="v022"><a class="header" href="#v022">v0.2.2</a></h2>
<ul>
<li>Improved tile animations with custom animation orders.</li>
<li>Improved documentation on tile animations</li>
</ul>
<h2 id="v021"><a class="header" href="#v021">v0.2.1</a></h2>
<ul>
<li>Renamed <code>LinceDeleteAnim</code> to <code>LinceDeleteTileAnim</code></li>
<li>LinceTileAnim: added optional maximum number of repeats</li>
<li>LinceTileAnim: added <code>on_repeat</code> and <code>on_finish</code> callbacks</li>
<li>Solved issue with test tilemap where black lines appear between tiles</li>
<li>Rebuilt html docs</li>
</ul>
<h2 id="v020"><a class="header" href="#v020">v0.2.0</a></h2>
<ul>
<li>Added basic tile animations</li>
</ul>
<h2 id="v010-alpha"><a class="header" href="#v010-alpha">v0.1.0 (alpha)</a></h2>
<ul>
<li>Basic 2D Renderer for quads</li>
<li>Basic texturing and tilesets</li>
<li>Event system for user input</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
